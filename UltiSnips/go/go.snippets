snippet append
${1:v} = append($1, $0)

endsnippet

snippet /^package/ "package declaration" r
package ${1:`!v expand('%:p:h:t')`}

endsnippet

snippet iferr "if err" b
if err != nil {
	log.${1:Fatal}(err)
}

endsnippet

# gs: if error: mask
snippet ifmask "if err mask" b
if err != nil {
	return $1microerror.Mask(err)
}

endsnippet

snippet printf "fmt.Printf()" b
fmt.Printf("${1:%#v}\n"${1/([^%]|%%)*(%.)?.*/(?2:, :\))/}$2${1/([^%]|%%)*(%.)?.*/(?2:\))/}
endsnippet

snippet panicf "panic(fmt.Sprintf(...))"
panic(fmt.Sprintf("$0"))
endsnippet

snippet log "o.logger.LogCtx(ctx, ..."
${1:receiver}.logger.LogCtx(ctx, "level", "${2:debug}", "message", "$0")
endsnippet

snippet logf "o.logger.LogCtx(ctx, ..."
${1:receiver}.logger.LogCtx(ctx, "level", "${2:debug}", "message", fmt.Sprintf("$0"))
endsnippet


snippet logerr "o.logger.LogCtx(ctx, ..."
${1:receiver}.logger.LogCtx(ctx, "level", "error", "message", "$0", "stack", fmt.Sprintf("%#v", err))
endsnippet

snippet logcancel "canceling resource reconciliation..."
${1:receiver}.logger.LogCtx(ctx, "level", "${2:debug}", "message", "canceling resource reconciliation for custom object")
endsnippet

#
# var invalidConfigError = ...
#
# Old snippet, cool example:
#var ${1/\s(\w)/\u$1/g}Error = microerror.New("${1:invalid config}")
snippet varerror "var *Error" b
var ${1:invalidConfig}Error = &microerror.Error{
	Kind: "$1Error",
}

// Is${1/./\u$0/} asserts $1Error.
func Is${1/./\u$0/}(err error) bool {
	return microerror.Cause(err) == $1Error
}
endsnippet

snippet varerrorre "error with regexp" b
var (
	$1Regexp = regexp.MustCompile(\`${0:\\S+ not exists}\`)
)

var ${1:notFound}Error = &microerror.Error{
	Kind: "$1Error",
}

// Is${1/./\u$0/} asserts $1Error.
func Is${1/./\u$0/}(err error) bool {
	if err == nil {
		return false
	}

	c := microerror.Cause(err)

	if c == $1Error {
		return true
	}
	if $1Regexp.MatchString(c.Error()) {
		return true
	}

	return false
}
endsnippet

#
# if config.N == nil {
#
snippet invalidconfig "if config.N == nil" b
if config.${1:Name} == ${2:nil} {
	return nil, microerror.Maskf(invalidConfigError, "%T.$1 must not be empty", config)
}

endsnippet

#
# if err := config.N.Validate(); err == nil {
#
snippet invalidconfigvalidate "if config.N == nil" b
if err := config.${1:Name}.Validate(); err != nil {
	return nil, microerror.Maskf(invalidConfigError, "config.$1.%s", err)
}
$0
endsnippet


#
# tc.errorMatcher
#
snippet iferrormatcher "if tc.errorMatcher ..." b
if err != nil {
	if tc.ErrorMatcher == nil {
		t.Fatalf("unexpected error %#v", err)
	} else if !tc.ErrorMatcher(err) {
		t.Fatalf("unexpected error %#v", err)
	}
}
$0
endsnippet

#
# table test
#
snippet test "table test" b
func Test_${1:Name}(t *testing.T) {
	testCases := []struct {
		name         string
		errorMatcher func(err error) bool
	}{
		{
			name:         "case 0",
			errorMatcher: nil,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			$0

			switch {
			case err == nil && tc.errorMatcher == nil:
				// correct; carry on
			case err != nil && tc.errorMatcher == nil:
				t.Fatalf("error == %#v, want nil", err)
			case err == nil && tc.errorMatcher != nil:
				t.Fatalf("error == nil, want non-nil")
			case !tc.errorMatcher(err):
				t.Fatalf("error == %#v, want matching", err)
			}

			if tc.errorMatcher != nil {
				return
			}
		})
	}
}
endsnippet

snippet testcheck "t.Fatalf"
if !reflect.DeepEqual(${1:Name}, tc.expected${1/.*/\u$0/}) {
	t.Fatalf("$1 == %v, want %v", $1, tc.expected${1/.*/\u$0/})
}
endsnippet
