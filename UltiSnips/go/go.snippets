snippet append
${1:v} = append($1, $0)
endsnippet

snippet ctx "ctx context.Context," w
ctx context.Context,
endsnippet

snippet /^package/ "package declaration" r
package ${1:`!v expand('%:p:h:t')`}

endsnippet

snippet iferr "if err" b
if err != nil {
	log.${1:Fatal}(err)
}

endsnippet

# gs: if error: mask
snippet ifmask "if err mask" b
if err != nil {
	return $1microerror.Mask(err)
}

endsnippet

snippet printf "fmt.Printf()" b
fmt.Printf("${1:%#v}\n"${1/([^%]|%%)*(%.)?.*/(?2:, :\))/}$2${1/([^%]|%%)*(%.)?.*/(?2:\))/}
endsnippet

snippet panicf "panic(fmt.Sprintf(...))"
panic(fmt.Sprintf("$0"))
endsnippet

snippet log "o.logger.LogCtx(ctx, ..."
${1:receiver}.logger.LogCtx(ctx, "level", "${2:debug}", "message", "$0")
endsnippet

snippet logf "o.logger.LogCtx(ctx, ..."
${1:receiver}.logger.LogCtx(ctx, "level", "${2:debug}", "message", fmt.Sprintf("$0"))
endsnippet


snippet logerr "o.logger.LogCtx(ctx, ..."
${1:receiver}.logger.LogCtx(ctx, "level", "error", "message", "$0", "stack", microerror.Stack(err))
endsnippet

snippet logcancel "canceling resource reconciliation..."
${1:receiver}.logger.LogCtx(ctx, "level", "${2:debug}", "message", "canceling resource reconciliation for custom object")
endsnippet

#
# if config.N == nil {
#
snippet invalidconfig "if config.N == nil" b
if config.${1:Name} == ${2:nil} {
	return nil, microerror.Maskf(invalidConfigError, "%T.$1 must not be empty", config)
}

endsnippet

#
# if err := config.N.Validate(); err == nil {
#
snippet invalidconfigvalidate "if config.N == nil" b
if err := config.${1:Name}.Validate(); err != nil {
	return nil, microerror.Maskf(invalidConfigError, "config.$1.%s", err)
}
$0
endsnippet


#
# tc.errorMatcher
#
snippet iferrormatcher "if tc.errorMatcher ..." b
if err != nil {
	if tc.ErrorMatcher == nil {
		t.Fatalf("unexpected error %#v", err)
	} else if !tc.ErrorMatcher(err) {
		t.Fatalf("unexpected error %#v", err)
	}
}
$0
endsnippet

#
# table test
#
snippet test "table test" b
func Test_${1:Name}(t *testing.T) {
	testCases := []struct {
		name         string
		errorMatcher func(err error) bool
	}{
		{
			name:         "case 0",
			errorMatcher: nil,
		},
	}

	for i, tc := range testCases {
		t.Run(strconv.Itoa(i), func(t *testing.T) {
			$0

			switch {
			case err == nil && tc.errorMatcher == nil:
				// correct; carry on
			case err != nil && tc.errorMatcher == nil:
				t.Fatalf("error == %#v, want nil", err)
			case err == nil && tc.errorMatcher != nil:
				t.Fatalf("error == nil, want non-nil")
			case !tc.errorMatcher(err):
				t.Fatalf("error == %#v, want matching", err)
			}

			if tc.errorMatcher != nil {
				return
			}
		})
	}
}
endsnippet
